python中的并发一般是通过多线程和多进程来实现的。
对于计算型任务，通常使用多进程来实现，对于IO型任务通过线程调度来让线程在执行IO任务时让出GIL，从而实现表面上的并发。
然而对于IO型任务也可以通过协程，协程是运行在单线程中的并发，协程相比多线程一大优势就是省去了多线程之间的切换开销，
从而获得更大的运行效率。

协程的作用就是在执行函数A时可以随时中断去执行函数B，然后中断函数B继续执行函数A（可以自由的切换）。
但这一过程并不是函数调用，看似像多线程，然而协程只有一个线程执行。

协程适合处理IO密集型任务，计算密集型任务可以结合多进程+协程。

多线程中，CPU对每个线程分配时间片，CPU本身做线程之间的调度（切换），每个线程中的阻塞行为不会影响到其他线程继续执行代码。

其实，所有的协程库，比如我们刚刚学习的 asyncio 和 gevent 等等，他们只是把阻塞行为的类库修改成了非阻塞行为的类库而已。
比如，我们以阻塞套接字为例： 当我们用 ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 定义一个阻塞套接字，
当用了协程库 gevent，你只需要加上 from gevent import monkey 和 monkey.patch_all() 两行代码，
协程库就相当于给我们的套接字加上一行代码 setblocking(False)，该代码就会让套接字变成非阻塞的套接字了，
这样一来，当程序执行原来的阻塞函数，比如 accept，recv 等等，就会马上挂起，当有其它任务时，就会去执行其它任务了，
这样就实现了单线程并发。

比如，python 的 sleep 函数也是阻塞的，如果使用协程库 gevent，并且执行代码 from gevent import monkey 和
monkey.patch_all() 后，阻塞的 sleep 就变成了非阻塞的函数，当程序执行到 sleep 代码时，程序就不会阻塞，gevent 就会挂起，
去调度其它任务。

注意，协程库只能动态的修改 Python 自带的一些标准库，为什么协程库 gevent 能把 requests 这种第三方库也修改成非阻塞的呢？
那是因为 requests 库本身用的就是基于 Pyhton 自带的标准库 socket 库啊！
但是，协程库并不是把所有的阻塞类库的行为变成非阻塞的行为，比如对 python 的阻塞函数input 使用协程库，就不会起作用。

在实际项目中可以使用协程异步的读写网络、读写文件、渲染界面等，而在等待协程完成的同时，CPU 还可以进行其他的计算，
协程的作用正在于此。那么协程和多线程的差异在哪里呢？多线程的切换需要靠操作系统来完成，当线程越来越多时切换的成本会很高，
而协程是在一个线程内切换的，切换过程由我们自己控制，因此开销小很多，这就是协程和多线程的根本差异。