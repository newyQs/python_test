"""

"""
# a=1, b=2,不用中间变量交换a和b的方法
a = 1
b = 2

# 交换方式1：
a = a + b
b = a - b
a = a - b

# 交换方式2：
a, b = b, a


# 继承
class Parent(object):
    x = 1


class Child1(Parent):
    pass


class Child2(Parent):
    pass


# print(Parent.x, Child1.x, Child2.x)
Child1.x = 2
# print(Parent.x, Child1.x, Child2.x)
Parent.x = 3
# print(Parent.x, Child1.x, Child2.x)

# 简述对input函数的理解
"""
在py3中，input函数的输出结果始终都是字符串(str)类型；
在py2中有raw_input和input函数，其中raw_input和py3中的input是一致的；
而py2中的input函数输入的是什么数据类型，返回什么数据类型；
"""

# py2中的range和xrange的区别
"""
两者的用法相同，不同的是range返回列表，xrange返回的是一个生成器。
前者是直接开辟一块内存空间保存列表，后者是边循环边使用，只有在使用时才会开辟内存空间。
"""

# 4G内存如何读取一个5G的数据？
"""
1. 可以通过生成器，分多次读取，每次读取数量相对少的数据（比如 500MB）进行处理，处理结束后在读取后面的 500MB 的数据。
2. 可以通过 linux 命令 split 切割成小文件，然后再对数据进行处理，此方法效率比较高。可以按照行数切割，可以按照文件大小切割。
"""

# 什么是可变和不可变数据类型？
"""
可不可变指的是内存中的值是否可以被改变。不可变类型指的是对象所在内存块里面的值不可以被改变，有数值，字符串，元组。
而可变类型则是可以改变，主要有列表，字典。
"""

# 如何理解\字符？
"""
3种含义：1、转义字符；2、路径中用来连接路径名；3、编写代码太长手动换行。
"""

# python中类方法，类实例方法，静态方法有何区别？
"""
类方法：是类对象的方法，在定义时需要在上方使用@classmethod进行装饰，形参为cls，表示类对象。类对象和实例对象都可以调用。
类实例方法：是类实例化对象的方法，只有实例对象才可以调用，形参为self，指代对象本身。
静态方法：是一个任意函数，在其上方使用@staticmethod进行装饰，可以用对象直接调用，实际静态方法和类无明显关系。
"""

# __init__ 和__new__的区别？
"""
init 在对象创建后，对对象进行初始化。
new 是在对象创建之前创建一个对象，并将该对象返回给 init。
"""

# Python 里面如何生成随机数？
"""
random.random()：生成一个 0-1 之间的随机浮点数；
random.uniform(a, b)：生成[a,b]之间的浮点数；
random.randint(a, b)：生成[a,b]之间的整数；
random.randrange(a, b, step)：在指定的集合[a,b)中，以 step 为基数随机取一个数;
random.choice(sequence)：从特定序列中随机取一个元素，这里的序列可以是字符串，列表，元组等。
"""

# 解释一下什么是闭包?
"""
在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为
闭包。
"""

# 函数装饰器有什么作用？
"""
装饰器本质上是一个 Python 函数，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装
饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。 比如：插入日志、性能测试、事务处理、缓存、
权限的校验等场景 有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。
"""

# 生成器、迭代器
"""
迭代器是一个更抽象的概念，任何对象，如果它的类有 next 方法和 iter 方法返回自己本身，对于 string、list、
dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句对容器对象调用 iter()函数，iter()
是 python 的内置函数。iter()会返回一个定义了 next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()
也是 python 的内置函数。在没有后续元素时，next()会抛出一个 StopIteration 异常。

生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数
据的时候使用 yield 语句。每次 next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置
和所有的数据值）

区别：生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且
生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当
发生器终结时,还会自动抛出 StopIteration 异常
"""

# yield 的用法


# Python 中的可变对象和不可变对象

